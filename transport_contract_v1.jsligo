namespace Transport_Contract {

    export type order = {
        buyer_address: address,
        origin : string,
        destination : string, 
        contract_deadline : timestamp, 
        transport_deadline : timestamp,
        winner_address : address,
        winner_price : nat
    };
    export type order_id = nat;
    export type last_id = nat; // Id of the lastest hash 

    export type storage = [map<order_id, order>, last_id];

    export type result = [list<operation>, [map<order_id, order>, last_id]];

    function force_access (key : nat, map : map<order_id, order>) {
        return match(Map.find_opt (key, map)){
            when(Some(value)): value;
            when(None) : failwith("No order")
        }
    };
 
    // Let's go from bugs to features ðŸ™‚
    // Here the buyer can enter its own TC, if thye want. (Or this is a "bad access"?)
    @entry  
    function CreateContract(new_order : order, oldStorage : storage) : result {
        let newID : nat = oldStorage[1] + 1n;
        let newMap : map<order_id, order> = Map.add(newID, new_order, oldStorage[0]);
        return [list([]), [newMap, newID]];
    }

    @entry 
    function CloseContract(buyer_address : address, idOfContract : nat, oldStorage : storage) : result {
        if (buyer_address != Tezos.get_sender()) {
            failwith("Access deny");
        }
        let newMap = Map.remove(idOfContract, oldStorage[0]);
        return [list([]), [newMap, oldStorage[1]]];
    }

    function GetTheOrderData(idOfContract : nat, oldStorage : storage) : order {
        if (!Map.mem(idOfContract, oldStorage[0])) {
            failwith("There is no such order.");
        }
        return force_access(idOfContract, oldStorage[0]);
    }

    function Participate(participater_address : address, 
            participater_price : nat, idOfOrder : nat, oldStorage : storage) : result {
        
        if (!Map.mem(idOfOrder, oldStorage[0])) {
            failwith("No such order"); // or return false;
        }
        
        let win_pr : nat = force_access(idOfOrder, oldStorage[0]).winner_price;
        if (participater_price < win_pr) {
            let newMap = match(Map.find_opt(idOfOrder, oldStorage[0])) {
                when(Some(i)): Map.update(idOfOrder, Some({
                    buyer_address : i.buyer_address, 
                    origin : i.origin,
                    destination : i.destination, 
                    contract_deadline : i.contract_deadline, 
                    transport_deadline : i.transport_deadline,
                    winner_address : participater_address,
                    winner_price : participater_price
                    }), oldStorage[0]);
                when(None): failwith("System of a down")
            };
            return [list([]), [newMap, oldStorage[1]]];
        } else {
            return [list([]), oldStorage];
        }
        // Here I should say, that the contract has not been updated.CloseContract
    }
}